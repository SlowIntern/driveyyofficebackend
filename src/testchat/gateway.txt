Documentation to understand websockets in nestjs

/--------------------------------------------------------------/
interface UserSocket extends Socket{
    User:any
}
explanation of above code with example
----
interface -> It is a way of defining shape of object.It tells what type of data user can hold
   example-:
     interface User {
        _id:string,
        name:string,
        age?:number // this property is optional but above two is not optional
     }

  Usersocket->It is a new interface it holds all the property of Socket
  extends Socket → It inherits all properties and methods of the Socket interface (from socket.io).
     Examples of Socket properties: id, handshake, emit(), on(), etc.
    
    User: any → Adds a new property User to the socket object.
/-----------------------------------------------------------------/

/-----------------------------------------------------------------/

@WebSocketGateway({
    cors:{
        origin:'*',
    },
})


@WebSocketGateway-> this is a nestjs decorator used to mark a class as a WebSocket Gateway.
It is bascially a server that can handle real-time-two-way-communication..

cors:{
    origin:'*'
}

cors->CORS allows you to define which domains can access your server.
origin '*' means allow all domain to connect to this websocket gateway..

/-------------------------------------------------------------------------/

/-------------------------------------------------------------------------/

export class ChatGateWay implements OnGateWayConnection ,OnGateWayDisonnection

ChatGateway->It is websocket gateway it is like a controller for webSocket events

~~Implements two Nestjs interface
    <> OnGateWayConnection->Allow you to define handleConnection()
    <> OnGateWayDisonnection-> Allow you to define handleDisconnection()

 @WebSocketServer()
 server:server

 @WebSocketServer()->It tells Nestjs to inject the actual WebSocket Server instance(Socket.IO server).
 server:Server-> the type is Socket.IO Server from socket.io.

 server->using server , i can broadcast events to all connected clients or a specific room/channel

/-----------------------------------BackendEvent for handleConnection---------------------------------------/

async handleConnection(socket : CustomSocket)
{
    let token;
    token=socket.handshake.headers.token;

    if(!token)
    {
        token=socket.handshake.query.token;
    }

    let type=socket.handshake.query.type;   //here type is flutter i think 

    console.log("type",type);
}

async handleDisconnect(socket: CustomSocket) {
    let token
    token = socket.handshake.headers.token;
    if (!token) {
        token = socket.handshake.query.token;
    }
    const update_socketId = await this.chatService.update_socket_id(
        token,
        socket?.id,
    );
    socket.emit('disconnected', 'Socket disconnected');
}


handleconnection run when client connected handledisconnection run when client disconnected

socket.handshake->Info sent from client during intial connection..

sockit.emit()-> Send message to client


frontend example---
// Frontend
const socket = io("http://localhost:5000", {
  query: { token: "abcd1234", type: "flutter" },
  extraHeaders: { Authorization: "Bearer abcd1234" }
});


/------------------------------------------------------------/

/------------------------------------------------------------/

Dto defination of CreateConnectionDto
  export class CreateConnectionDto{
    booking_id:string;
  }

@UseGaurd(SocketGuard)
@SubscribeMessage('connection-established')
async handleCreateConnection(socket:UserSocket,body:CreateConnectionDto)
{
    let user_data;
    let user_detail;
    let booking;
    let response;

    if(socket.user.scope===driver){
        booking=await this.chatService.bookinDetail(body.booking_id); // this will return booking detail with the booking_id i provide..
        response=await this.chatService.create_connection(        // write this function...
            socket.user.user_id, // this is driver_id            //    
            booking.customer_id, // this is customer_id
            socket.user.scope    // contain scope like drive..
        );

        user_data=await this.chatService.findDriver(socket.user.user_id);   // this will find driver detail from the database.
        user_detail=await this.chatService.findCustomer(booking.customer_id); // this will find customer detail from the datbase. 
    }
    else if(socket.user.scope==='customer')
    {
            booking = await this.chatService.bookingDetail(body.booking_id)  //same as booking detail from the database
            response = await this.chatService.create_connection(
                booking.driver_id,
                socket.user.user_id,
                socket.user.scope
            );
            user_data = await this.chatService.findCustomer(socket.user.user_id )  //customer detail from the database.
            user_detail = await this.chatService.findDriver(booking.driver_id)    //driver detail from the database.
    }

    let data={
        response,
        user_detail:user_detail,
        booking:booking._id
    }

    this.server.to(user_data.socket_id).emit('create-connection',data);
}



The create connection function used in code

async create_connection(driver_id, customer_id, scope) {
    try {
      const find_connection_id = await this.model.connections.findOne({
        driver_id: driver_id,
        customer_id: customer_id,
      });
      if (find_connection_id) {
        if (scope === 'customer') {
            await this.model.customers.updateOne(
              { _id: customer_id },
              { connection_id: find_connection_id._id },
            );
        } else {
            await this.model.drivers.updateOne(
              { _id: driver_id },
              { connection_id: find_connection_id._id },
            );
        }
        return find_connection_id._id;
      } else {
        const create_connection = await this.model.connections.create({
          driver_id: driver_id,
          customer_id: customer_id,
        });
        if (scope === 'customer') {
            await this.model.customers.updateOne(
              { _id: customer_id },
              { connection_id: find_connection_id._id },
            );
        } else {
            await this.model.drivers.updateOne(
              { _id: driver_id },
              { connection_id: find_connection_id._id },
            );
        }
        return create_connection._id;
      }
    } catch (error) {
      console.log('error', error);
      throw error;
    }
  }


  resume after lunch....



